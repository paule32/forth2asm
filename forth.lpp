%{
// --------------------------------------------------------------------------------
// MIT License
//
// Copyright (c) 2018 Jens Kallup
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// exec example: fort2pas --mode pascal --auto source.f
//
// Legend: --mode = pascal transpile
//         --auto = _no_ interactive run
// --------------------------------------------------------------------------------

#include "common.h"

#define YYDEBUG 1
#define YYTYPE yylval

#include "forth.tab.hpp"
#undef yywrap
int    yywrap() { return 1; }

%}

%option noyywrap
%option caseless

DIGIT       [0-9]
num         {DIGIT}+
ws          [ \t\n\r]
REMS1       ^[c|C].*\n
gotoline    ^[0-9]+
ident       [a-zA-Z]+[a-zA-Z0-9_]*
hexdigit    \B\#(?:[a-fA-F0–9]{6}|[a-fA-F0–9]{3})\b

qoutedstr   (["']).*(['"])

dimsid0     {ws}*{ident}{ws}*"("
dimsid1     {ws}*{ident}{ws}*
dimsid2     {ws}*","{ws}*

dimsidA     {dimsid0}{dimsid1}")"
dimsidB     {dimsid0}({dimsid1}{dimsid2}{dimsid1})*{ws}*")"

listsep     (({dimsid1})([,]{dimsid1})*)

l_not       (\.[n|N][o|O][t|T]\.)
l_and       (\.[a|A][n|N][d|D]\.)
l_or        (\.[o|O][r|R]\.)
l_xor       (\.[x|X][o|O][r|R]\.)
l_eqv       (\.[e|E][q|Q][v|V]\.)
l_neq       (\.[n|N][e|E][q|Q][v|V]\.)

l_false     (\.[f|F][a|A][l|L][s|S][e|E]\.)
l_true      (\.[t|T][r|R][u|U][e|E]\.)

%x subser subser_parameter dimens ident_or_num_or_str integers reals doubles complexes
%x precisions characters logicals complexs programs gotos parameters
%x parameters_num_str
%x parameters_num_str2 parameters_num_str3
%x parameters_num_str4 parameters_num_str5 parameters_num_str6
%x subser_1
%x subser_2
%x subser_3

%x l_not l_and l_or l_xor l_eqv l_neq

%%

^\!.*\n     { /*yytext[ext::strlen(yytext)-2] = '\0'; std::cout << ext::yypadding(yytext) << std::endl; */ }
^\*.*\n     { /*yytext[ext::strlen(yytext)-2] = '\0'; std::cout << ext::yypadding(yytext) << std::endl; */ }
^[c|C].*\n  { /*yytext[ext::strlen(yytext)-2] = '\0'; std::cout << ext::yypadding(yytext) << std::endl; */ }

{ws}*       { }
\n*         { ++yylineno; }

([l|L][o|O][g|G][i|I][c|C][a|A][l|L])                { BEGIN(logicals);   }
([i|I][n|N][t|T][e|E][g|G][e|E][r|R])                { BEGIN(integers);   }
([r|R][e|E][a|A][l|L])                               { BEGIN(reals);      }
([d|D][o|O][u|U][b|B][l|L][e|E])                     { BEGIN(doubles);    }
([c|C][o|O][m|M][p|P][l|L][e|E][x|X])                { BEGIN(complexs);   }
([c|C][a|A][r|R][a|A][c|C][t|T][e|E][r|R])           { BEGIN(characters); }
([d|D][i|I][m|M][e|E][n|n][s|S][i|I][o|O][n|N])      { BEGIN(dimens);     }
([s|S][u|U][b|B][r|R][o|O][u|U][t|T][i|I][n|N][e|E]) { BEGIN(subser);     }
([p|P][r|R][o|O][g|G][r|R][a|A][m|M])                { BEGIN(programs);   }
([g|G][o|O][t|T][o|O])                               { BEGIN(gotos);      }
([p|P][a|A][r|R][a|A][m|M][e|E][t|T][e|E][r|R])      { BEGIN(parameters); }

({ident}){ws}*"\="{ws}* {
    if (ext::convert_mode == ext::CVT_PASCAL) {
        std::string st = yytext;
        ext::replaceStr(st,
        std::string("="),
        std::string(":="));

        add_cod(st);

        std::string s2 = yytext;
        ext::replaceStr(s2,std::string("=" ),std::string(""));
        ext::replaceStr(s2,std::string(" " ),std::string(""));
        ext::replaceStr(s2,std::string("\n"),std::string(""));
        ext::replaceStr(s2,std::string("\t"),std::string(""));
        ext::replaceStr(s2,std::string("\r"),std::string(""));
        ext::current_var = s2;
    }
    BEGIN(ident_or_num_or_str);
}

<ident_or_num_or_str>{ident} {
    std::stringstream ss;
    ss << yytext;
    ss << ";";
    ss << std::endl;
    ext::current_var = std::string(yytext);

    if (ext::convert_mode == ext::CVT_PASCAL) {
        add_cod(ss.str());
    }
    BEGIN(INITIAL);
}
<ident_or_num_or_str>{num} {
    std::stringstream ss;
    ss << yytext;
    ss << ";";
    ss << std::endl;

    if (ext::convert_mode == ext::CVT_PASCAL) {
        add_cod(ss.str());
    }
    BEGIN(INITIAL);
}
<ident_or_num_or_str>{qoutedstr} {
    std::stringstream ss;
    ss << yytext;
    ss << ";";
    ss << std::endl;

    if (ext::convert_mode == ext::CVT_PASCAL) {
        add_var_char(ext::current_var);
        add_cod(ss.str());
    }
    BEGIN(INITIAL);
}

{gotoline}  {
    std::string st =
    std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\t");

    if (ext::convert_mode == ext::CVT_ASM) {
    std::stringstream ss;
    ss  << std::string("L")
        << std::string(yytext)
        << std::string(":\n");
           std::cout << ss.str();
    }   else
    if (ext::convert_mode == ext::CVT_PASCAL) {
        std::stringstream s1,s2;
        s1 << std::string("Label");
        s1 << std::string(st);

        s2 << s1.str();
        s2 << std::string(":");
        s2 << std::endl;

        add_lbl(s1.str());
        add_cod(s2.str());
    }

    BEGIN(INITIAL);
}

<parameters>{ws}*\({ws}*          { BEGIN(parameters_num_str2); }
<parameters_num_str2>{ws}*\)      { BEGIN(INITIAL); }
<parameters_num_str2>{ws}*{ident} {
    ext::current_var = std::string(yytext);
    BEGIN(parameters_num_str3);
}
<parameters_num_str3>{ws}*\={ws}*    { BEGIN(parameters_num_str4); }

<parameters_num_str3>{ws}*\,{ws}*\)  { yyerror(yyerror_str1[LOCALES_LANG]); exit(1); }
<parameters_num_str3>{ws}*\={ws}*\)  { yyerror(yyerror_str2[LOCALES_LANG]); exit(1); }
<parameters_num_str3>{ws}*\/{ws}*\)  { yyerror(yyerror_str3[LOCALES_LANG]); exit(1); }

<parameters_num_str3>{ws}*\)         { BEGIN(INITIAL); }

<parameters_num_str4>{num}           {
    add_cnst(ext::current_var,std::string(yytext));
    BEGIN(parameters_num_str5);
}
<parameters_num_str4>{ident}         {
    BEGIN(parameters_num_str5);
}

<parameters_num_str5>{ws}*\,{ws}*\)  { yyerror(yyerror_str1[LOCALES_LANG]); exit(1); }
<parameters_num_str5>{ws}*\={ws}*\)  { yyerror(yyerror_str2[LOCALES_LANG]); exit(1); }
<parameters_num_str5>{ws}*\/{ws}*\)  { yyerror(yyerror_str3[LOCALES_LANG]); exit(1); }

<parameters_num_str5>{ws}*{num}      { BEGIN(parameters_num_str6); }
<parameters_num_str5>{ws}*{ident}    { BEGIN(parameters_num_str6); }

<parameters_num_str6>{ws}*\,{ws}*\)  { yyerror(yyerror_str1[LOCALES_LANG]); exit(1); }
<parameters_num_str6>{ws}*\={ws}*\)  { yyerror(yyerror_str2[LOCALES_LANG]); exit(1); }
<parameters_num_str6>{ws}*\/{ws}*\)  { yyerror(yyerror_str3[LOCALES_LANG]); exit(1); }

<parameters_num_str6>{ws}*\,         { BEGIN(parameters_num_str2); }
<parameters_num_str6>{ws}*\)  {
    BEGIN(INITIAL);
}


<logicals>{listsep} {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\t ");

    std::vector<std::string> var_stl;
    var_stl = ext::split(st,',');

    for (auto &v : var_stl) {
        add_var_bool(v);
    }

    BEGIN(INITIAL);
}
<integers>{listsep} {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\t ");

    std::vector<std::string> var_stl;
    var_stl = ext::split(st,',');

    for (auto &v : var_stl) {
        add_var_int(v);
    }

    BEGIN(INITIAL);
}
<integers>\n ++yylineno;

<reals>{listsep} {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\t ");

    std::vector<std::string> var_stl;
    var_stl = ext::split(st,',');

    for (auto &v : var_stl) {
        add_var_real(v);
    }

    BEGIN(INITIAL);
}
<doubles>{ws}*([p|P][r|E][c|C][i|I][s|S][i|I][o|O][n|N]){ws}* {
    BEGIN(precisions);
}
<precisions>{listsep} {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\t ");

    std::vector<std::string> var_stl;
    var_stl = ext::split(st,',');

    for (auto &v : var_stl) {
        add_var_double(v);
    }

    BEGIN(INITIAL);
}
<characters>{listsep} {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\t ");

    std::vector<std::string> var_stl;
    var_stl = ext::split(st,',');

    for (auto &v : var_stl) {
        add_var_char(v);
    }

    BEGIN(INITIAL);
}

<gotos>{ws}*({num}) {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"goto ");

    if (ext::convert_mode == ext::CVT_ASM) {
        std::cout <<
        std::string("\tjmp\tL") <<
        std::string(st)         <<
        std::string("\n");
    }   else
    if (ext::convert_mode == ext::CVT_PASCAL) {
        std::stringstream ss;
        ss << std::string("goto Label") << st << ";" << std::endl;
        ext::current_flag = ext::forth_flags::e_forth_goto;
        add_cod(ss.str());
    }

    BEGIN(INITIAL);
}

<programs>{ws}*{ident} {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\r\t ");
    ext::current_flag = ext::forth_flags::e_forth_program;
    ext::current_prg  = st;
    add_prg(st);
    BEGIN(INITIAL);
}
([e|E][n|N][d|D]) {
    std::string st = std::string(yytext);
    ext::removeCharsFromString(st,(char*)"\n\r\t ");
    ext::current_flag = ext::forth_flags::e_forth_end;
    //add_cod(st);

    BEGIN(INITIAL);
}

<dimens>(({dimsidA}|{dimsidB})|(({dimsidA}|{dimsidB}){ws}*","{ws}*({dimsidA}|{dimsidB}))) {
#if 0
    std::cout << std::string("\ndimensA: ") << std::string(yytext);
#endif
    BEGIN(INITIAL);
}

<subser>{ws}*   { }
<subser>{ident} {
    if (ext::convert_mode == ext::CVT_ASM) {
        std::cout << std::string(yytext) << ":" << std::endl;

        std::cout << "\tpush\tebp"     << std::endl;
        std::cout << "\tmov\tebp, esp" << std::endl;
    }   else
    if (ext::convert_mode == ext::CVT_PASCAL) {
        add_proc(std::string(yytext));
    }

    BEGIN(subser_parameter);
}
<subser>\n   { ++yylineno; }

<subser_parameter>{ws}*\(     { BEGIN(subser_2); }
<subser_2>{ws}*\)             { BEGIN(INITIAL);  }
<subser_2>{ws}*{ident}        { BEGIN(subser_3); }
<subser_1>{ws}*{ident}        { BEGIN(subser_3); }
<subser_1>{ws}*{ident}{ws}*\) { BEGIN(INITIAL);  }
<subser_3>{ws}*\,             { BEGIN(subser_1); }
<subser_3>{ws}*\)             { BEGIN(INITIAL);  }

<subser_parameter>\n  { ++yylineno; }

.   {
    yyerror("unknow character.");
    exit(1);
}

<<EOF>>         { return 0; }
%%

//-- FUNCTION DEFINITIONS ---------------------------------
int main(int argc, char **argv)
{
    std::vector<std::string> forth_files;
    int opt, c;
    int idx;

    static const struct option long_options[] =
    {
        { "mode",    required_argument, 0, 400 },
        { "auto",    no_argument,       0, 401 },
        { "verbose", no_argument,       0, 402 },
        { "version", no_argument,       0, 404 },
        { "help",    no_argument,       0, 408 },
        { 0     ,    0          ,       0,  0  }
    };

    std::cout << "forth2asm (c) 2019 Jens Kallup - non profit Software" << std::endl;
    std::cout << "all rights reserved."    << std::endl                 << std::endl;

    if (argc < 2) {
        std::cout << "no parameter given." << std::endl;
        return 1;
    }

    int w_flag = 0;
    #define macro_w_flag 1

    while (1) {
        opt = optind ? optind : 1;
        idx = 0;
        if ((c = getopt_long(argc, argv, "abc:d", long_options, &idx)) < 0) {
            break;
        }
        switch (c) {
        case 0:
            printf("option %s", long_options[idx].name);
            if (optarg)
                printf(" with arg %s", optarg);
            printf("\n");
            break;

        case 400:
        {
            if (ext::strlen(optarg) == 7) {
                if (optarg[0] == 'p'
                &&  optarg[1] == 'a'
                &&  optarg[2] == 's'
                &&  optarg[3] == 'c'
                &&  optarg[4] == 'a'
                &&  optarg[5] == 'l') {
                ext::convert_mode = ext::CVT_PASCAL;
                } else {
                  std::cout << "unknow converter mode" << std::endl;
                  return 1;
            }   } else
            if (ext::strlen(optarg) == 4) {
                if (optarg[0] == 'a'
                &&  optarg[1] == 's'
                &&  optarg[2] == 'm') {
                ext::convert_mode = ext::CVT_ASM;
                } else {
                  std::cout << "unknow converter mode" << std::endl;
                  return 1;
            }   } else {
                  std::cout << "unknow converter mode" << std::endl;
                  return 1;
            }
            std::cout << "source file will be converted to: " << optarg << std::endl;
        }
        break;

        case 401:
            w_flag = macro_w_flag;
            break;

        case 402:
            printf("option verbose\n");
            break;

        case 404:
            printf("version: 0.0.1 alpha\n");
            break;

        case 408:
            printf(
            "Fortran Transpiller - options:\n"
            " --mode     mode = asm, pascal\n");
            break;

        case '?':
            break;

        default:
            printf("?? getopt returned character code 0%o ??\n", c);
        }
    }

    if (optind < argc) {
        while (optind < argc) {
            if (!(ext::file_pile[optind] = fopen(argv[optind],"r"))) {
                optind += 1;
                char buffer[200];
                sprintf(buffer,"can't open file: %s",argv[optind-1]);
                perror (buffer);
                return 1;
            }
            else {
                fclose(ext::file_pile[optind]);
                forth_files.push_back(argv[optind]);
            }
        }
    }
    else {
        std::cout << "no input file specified." << std::endl;
        return 1;
    }

    // !! todo
    std::string input_file ;
    std::string reput_file ;

    if (forth_files.size() > 0)
    input_file = forth_files[0];  else
    input_file = std::string("stdin");

    reput_file = input_file;

    if (ext::convert_mode == ext::CVT_PASCAL) reput_file.append(".pas"); else
    if (ext::convert_mode == ext::CVT_ASM   ) reput_file.append(".asm");

    FILE *fr = fopen(input_file.c_str(),"r"); if (!fr) return yyerror("can not open input file!");
    FILE *fw = fopen(reput_file.c_str(),"w"); if (!fw) return yyerror("can not open write file!");

    fseek(fr, 0, SEEK_END); ext::yyget_line_gap = ftell(fr);
    fseek(fr, 0, SEEK_SET);

    // get lines of "fr" ...
    int  _lineno = 1;
    char ch;
    do {
        ch = fgetc(fr);
        if (ch == '\n') ++_lineno;
    } while (ch != EOF);

    fseek(fr, 0, SEEK_SET);

    // for listing mode
    char buffer[] = "1234567890abcdefghijklmnopqrstuvwxyz";
    sprintf(buffer,"%d",ext::yyget_line_gap);
    ext::yymet_line_gap = ext::strlen(buffer);

    yyset_in (fr);
    yyset_out(fw);
    yyset_lineno(0);

    // parse/lex code ...
    int result = yyparse();
    int plen   = 0;

    // write code ...

    auto pas = ext::forth_pascal;
    auto prg = pas.front();

    std::stringstream ss,s1;
    std::stringstream s2,s3,s4;
    std::string       prg_path("./out/");

    s2.str("");
    s2 << prg_path << "pas";

    // work both: Linux/Windows:
    struct stat sb;
    if (stat(prg_path.c_str(), &sb) == 0 && S_ISDIR(sb.st_mode)) {    // yes
        char pass;
        if (w_flag == macro_w_flag) {
            goto auto_label;
        }
        else {
            while (1) {
                fflush(stdin);
                std::cout << std::endl << "Warning: output directory exists, delete it? [y/n]: ";
                fscanf(stdin,"%c", &pass);
                fflush(stdin);
                if (pass == 'n') {
                    std::cerr << "abort transpile." << std::endl;
                    fclose(fr);
                    fclose(fw);
                    exit(1);
                }
                else if (pass == 'y') {
                    goto auto_label;
                    break;
                }
                else {
                    continue;
                }
            }
        }
    }
    auto_label:
        s1.str("");
        s1 << "rm -rf ";
        s1 << prg_path ;

        s3.str("");
        s3 << "mkdir -p ";
        s3 << s2.str();

        // WARNING: all data in the out folder will be lost !!!
        system(s1.str().c_str());
        system(s3.str().c_str());
    auto_next:

    FILE * program_file = nullptr;
    for (auto &pro : pas)
    {
        // please keep this - code of conduct ...
        ss.str("");
        ss << banner();

        s4.str("");   // clear
        s4 << "./out/pas/";
        s4 << pro.id_name << "/";

        s3.str("");
        s3 << "mkdir -p ";
        s3 << s4.str();
        system(s3.str().c_str());

        // subroutine = unit
        auto subs = pro.proc;
        if (subs.size() > 0) {
            for (auto &sub : subs) {
                s4.str("");   // clear
                s4 << "./out/pas/";
                s4 << pro.id_name << "/";
                s4 << sub.id_name;
                s4 << ".pas";

                program_file = fopen(s4.str().c_str(),"w");
                if (!program_file) {
                    std::cerr << "Fopen error: " << strerror(errno) << std::endl;
                    break;
                }

                ss << "unit " << sub.id_name << ";" << std::endl;
                ss << "interface"      << std::endl;
                ss << "implementation" << std::endl;

                ss << "end." << std::endl;

                fprintf(program_file,"%s",ss.str().c_str());
                fflush (program_file);
                fclose (program_file);
            }
        }

        if (pro.id_name.size() > 0)
        {
            // please keep this - code of conduct ...
            ss.str("");
            ss << banner();

            s2.str("");
            s2 << prg_path;
            s2 << "pas/";
            s2 << pro.id_name;

            s3.str("");
            s3 << "mkdir -p ";
            s3 << s2.str();
            system(s3.str().c_str());

            // program
            s4.str("");   // clear
            s4 << s2.str();
            s4 << "/";
            s4 << pro.id_name;
            s4 << ".pas";

            program_file = fopen(s4.str().c_str(),"w");
            if (!program_file) {
                std::cerr << "fopen error: " << strerror(errno) << std::endl;
                break;
            }

            ss << std::string("(* ======== PROGRAM ========== *)") << std::endl;
            ss << "program ";
            ss << pro.id_name  << ";" << std::endl;

            auto ppv = pro.vars_bool;
            if (ppv.size() > 0){
                ss << "(* -------- VARIABLE: bool --- *)" << std::endl;
                int plen = 0;
                ss << "var" << std::endl;
                for (auto &var : ppv)
                {
                    ++plen;
                    ss << var.id_name;
                    if (plen > ppv.size()-1) {
                        ss << ": Boolean;" << std::endl;
                    }   else {
                        ss << ",";
                    }
                }
            }
            auto ppi = pro.vars_int;
            if (ppi.size() > 0){
                ss << "(* -------- VARIABLE: int ---- *)" << std::endl;
                int plen = 0;
                ss << "var" << std::endl;
                for (auto &var : ppi)
                {
                    ++plen;
                    ss << var.id_name;
                    if (plen > ppi.size()-1) {
                        ss << ": Integer;" << std::endl;
                    }   else {
                        ss << ",";
                    }
                }
            }
            auto ppr = pro.vars_real;
            if (ppr.size() > 0){
                ss << "(* -------- VARIABLE: real --- *)" << std::endl;
                int plen = 0;
                ss << "var" << std::endl;
                for (auto &var : ppr)
                {
                    ++plen;
                    ss << var.id_name;
                    if (plen > ppr.size()-1) {
                        ss << ": Real;" << std::endl;
                    }   else {
                        ss << ",";
                    }
                }
            }
            auto ppd = pro.vars_real;
            if (ppd.size() > 0){
                ss << "(* -------- VARIABLE: double - *)" << std::endl;
                int plen = 0;
                ss << "var" << std::endl;
                for (auto &var : ppd)
                {
                    ++plen;
                    ss << var.id_name;
                    if (plen > ppd.size()-1) {
                        ss << ": Double;" << std::endl;
                    }   else {
                        ss << ",";
                    }
                }
            }
            auto ppc = pro.vars_char;
            if (ppc.size()){
                ss << "(* -------- VARIABLE: char --- *)" << std::endl;
                int plen = 0;
                ss << "var" << std::endl;
                for (auto &var : ppc)
                {
                    ++plen;
                    ss << var.id_name;
                    if (plen > ppc.size()-1) {
                        ss << ": String;" << std::endl;
                    }   else {
                        ss << ",";
                    }
                }
            }
            auto pc2 = pro.cnst;
            if (pc2.size()) {
                ss << "(* -------- CONSTANT items --- *)" << std::endl;
                ss << "const" << std::endl;
                for (auto &var : pc2)
                {
                    ss << var.id_name;
                    ss << " = ";
                    ss << var.id_data;
                    ss << ";" << std::endl;
                }
            }

            auto ppa = pro.lbls;
            if (ppa.size() > 0){
                ss << "(* -------- LABEL's ---------- *)" << std::endl;
                int plen = 0;
                ss << "label" << std::endl;
                for (auto &lbl : ppa)
                {
                    ++plen;
                    ss << lbl.id_name;
                    if (plen > ppa.size()-1)
                    ss << ";"; else
                    ss << ",";
                }   ss << std::endl;
            }

            ss << "begin" << std::endl;

            auto pcc = pro.cods;
            if (pcc.size() > 0){
                ss << "(* -------- CODE ------------- *)" << std::endl;
                for (auto &cod : pcc) {
                    ss << cod.id_name;
                }
            }
            ss << "end." << std::endl;

            fprintf(program_file,"%s",ss.str().c_str());
            fflush (program_file);
            fclose (program_file);
        }
    }

    std::cout << "compiled lines: " << _lineno << std::endl;
    std::cout << "done." <<
    std::endl;

    fclose(fr);
    fclose(fw);
    return result;
}

